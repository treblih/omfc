/*
 * =====================================================================================
 *
 *       Filename:  generics.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  31.03.10
 *       Revision:  
 *       Compiler:  GCC 4.4.3
 *
 *         Author:  Yang Zhang, imyeyeslove@gmail.com
 *        Company:  
 *
 * =====================================================================================
 */

#define		GENERICS_IMPLEMENTATION
#include	<omfc/omfc.h>

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  new
 *  Description:  new == calloc(allocate space in heap) + ctor(init)
 *
 *  		  must be a class pointer
 * =====================================================================================
 */
OBJ gnew(OBJ _cls, ...)
{
	va_list arg;
	va_start(arg, _cls);
	OBJ obj = ginit(galloc(_cls), &arg);
	va_end(arg);
	return obj;
} 

OBJ galloc(OBJ _cls)
{
	typedef OBJ(*FUNC)();
	CLS cls;

	if ((PTR)_cls < gheap) {
		cls = gcast(Class, (*(FUNC)_cls)());
	} else {
		cls = gcast(Class, _cls);
	}
	OBJ obj = calloc(1, cls->size);
	obj->class = (OBJ)cls;
	return obj;
}

OBJ ginit(OBJ _obj, va_list * _arg)
{
	CLS cls = gcast(Class, gclass_of(_obj));
	OBJ obj = cls->ctor(_obj, _arg);
	return obj;
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  delete
 *  Description:  just free. 'cause no need to finit
 * =====================================================================================
 */
void gdelete(OBJ _obj)
{
	if (_obj) {
		/* CLS cls = gcast(Class, gclass_of(_obj)); */
		$private(Class) * obj = ($private(Class) *) _obj;
		$do(obj, dtor);
		free(_obj);
	}
}

PTR gcast(OBJ _down, OBJ _up)  
{
	assert(!gis_of(_down, _up));
	return (PTR) _up;
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  gclass_of
 *  Description:  class of a given object
 *
 *  		  the only thing that one object always have is a pointer to it's class
 * =====================================================================================
 */
OBJ gclass_of(OBJ _obj)
{
	return _obj->class;
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  gsize_of
 *  Description:  a object may not have it's size element, so can't "->size" directly
 *  		  but it was generated by it's class-desc, so it has the record of
 *  		  the object
 * =====================================================================================
 */
size_t gsize_of(OBJ _obj)
{
	CLS cls = gcast(Class, gclass_of(_obj));
	return cls->size;
}

BOOL gis_of(OBJ _down, OBJ _up)
{
	if (_up == Nil) {
		return false;
	}

	OBJ cls;
	while (_down != Nil) {
		if (_up == (cls = gclass_of(_down))) {
			 return true;
		} else {
			_down = cls;
		}
	}
	return false;
}

void ginit_class(OBJ _sub, OBJ _spr, size_t _copy_len, size_t _private_len, int _pair, ...)
{
	memcpy(_sub, _spr, _copy_len);

	CLS cls = gcast(Class, _sub);
	cls->size = _private_len;

	va_list ap;
	va_start(ap, _pair);
	off_t offset;
	FUNC * ptr;

	for (int i = 0; i < _pair; i += 1) {
		offset = va_arg(ap, off_t);
		ptr = (FUNC *)((char *)_sub + offset);
		*ptr = va_arg(ap, FUNC);
	}
	va_end(ap);
}
